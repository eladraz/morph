namespace clrcore
{
    /*
     * The VirtualTable class resposible for vtbl/interface operation. These operating is used by the "isinst" instruction,
     * in exception handling code and in "callvirt" instruction to interfaces
     *
     * The vTbl is generated by the ELFLinker and MemoryLinker. The structurure of the virtual table, documented in
     * both "executer/ELFLinker.cpp and MemoryLinker.cpp" and in this C# file VirtualTable.cs
     *
     * Every change suppose to be in sync in both compilation environments
     *
     * For each typedef (Both classes and interfaces has the following structure) for the vtbl to be pointed at.
     * Interfaces doesn't have any vtbl functions, only inheritance tree:
     *
     * NOTE: Parent table is a flat model, which means that all parents for the class exists in the table.
     *
     * For x32 bit calls (4 bytes for call):
     *
     *           FFF0 -> RTTI parent, offset
     *           FFF4 -> RTTI parent, offset
     *           FFF8 -> RTTI this,   offset
     *  parents# FFFC -> 3 (2+1)                                        Number of parents (including self) (2)
     *           FFFE -> object size
     *      vtbl 0000 -> v0()  - destructor pointer (*)
     *           0004 -> v1()
     *           0008 -> v2()
     *           000C -> v3()
     *
     * Auther: Elad Raz
     */
    class VirtualTable
    {
        public unsafe struct ParentEntry
        {
            public ushort m_rtti;       // Parent vTbl offset
            public ushort m_offset;     // Offset within the class
        }

        public unsafe struct VirtualTableHeader
        {
            public ushort  m_numberOfParents;
            public ushort  m_objectSize;
        }

        internal unsafe static VirtualTableHeader* getVirtualTableHeader(void* vTbl)
        {
            return ((VirtualTableHeader*)vTbl) - 1;
        }


        protected unsafe static uint virtualTableParents(void* vTbl, ParentEntry** table)
        {
            VirtualTableHeader* header = getVirtualTableHeader(vTbl);
            ushort size = header->m_numberOfParents;
            *table = ((ParentEntry*)(header)) - size;
            return size;
        }

        /*
         * From vTbl object, return the object's RTTI
         */
        public unsafe static ushort getObjectRTTI(void* vTbl)
        {
            ParentEntry* pTable;
            uint size = virtualTableParents(vTbl, &pTable);
            return pTable[size - 1].m_rtti;
        }

        /*
         * From a parent vtbl and interface vtbl, scan the parent list and find the location of the child inhertiance.
         *
         * return (uint)(-1) if the objects are not inherit from each other
         */
        internal unsafe static uint virtualTableGetInterfaceLocation(void* parentvTbl, ushort childRtti)
        {
            ParentEntry* pTable;
            uint size = virtualTableParents(parentvTbl, &pTable);

            for (int i = 0; i < size; i++)
            {
                if (pTable[i].m_rtti == childRtti)
                {
                    return (uint)(pTable[i].m_offset * sizeof(uint));
                }
            }

            return 0xFFFFFFFF;
        }

        internal unsafe static void* virtualTableIsInstance(void* obj, ushort childRtti)
        {
            void* parentvTbl = GarbageCollector.garbageCollectorGetVTbl(obj);
            if (parentvTbl == null)
                return null;

            if (virtualTableGetInterfaceLocation(parentvTbl, childRtti) == 0xFFFFFFFF)
                return null;

            return obj;
        }

        internal unsafe static void virtualTableCheckIsInstance(void* parentvTbl, ushort childRtti)
        {
            if (virtualTableGetInterfaceLocation(parentvTbl, childRtti) == 0xFFFFFFFF)
            {
                Morph.Imports.assertFalse();
                throw new System.InvalidCastException();
            }
        }
    }
}
